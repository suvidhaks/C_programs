Algorithm implementation from thomas coreman textbook


// thomas coreman algo. implementation
#include <stdio.h>
int binarysearch(int a[], int n, int key);
int main() {
    // Write C code here
   int a[20], n, low, high,key, i, mid, ans;
  
   printf("enter n value");
   scanf("%d", &n);
  //  low=0, high=n-1;
   for(i=0;i<n;i++)
   {
       scanf("%d", &a[i]);
   }

printf("enter the key");
scanf("%d", &key);

 ans=binarysearch( a,  n,  key);
 printf("%d", ans);

    return 0;
}



int binarysearch(int a[], int n,  int key)
{
    int mid;
    int low=0, high=n-1;
while( low<=high)
{
    mid=(low+high)/2;
    if(a[mid]==key)
    {
      return mid;
    }
      else if(a[mid]>key)
      {
        high=mid-1;
      }
    else if(a[mid]<key)
    {
        low=mid+1; 
    }
}
return -1;
}

//…………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………….


// thomas coreman algo. implementation factorial recurssion
#include <stdio.h>
int factorial( int );
int main() {
    // Write C code here
   int  n,ans;
  
   printf("enter n value");
   scanf("%d", &n);
  ans=factorial(n);
  printf("%d", ans);

    return 0;
}



int factorial( int n)
{
    if(n==0)
     return 1;
    else
      return n*factorial(n-1);
}


…………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………….



// thomas coreman algo. implementation linear search
#include <stdio.h>
int linearsearch( int a[], int n, int key);
int main() {
    // Write C code here
   int a[20], n,key,i,ans,loc=0;
   printf("enter n");
   scanf("%d", &n);
   printf("enter n elements");
   for(i=0;i<n;i++)
   {
       scanf("%d", &a[i]);
   }
  printf("enter key");
  scanf("%d", &key);
  ans=linearsearch(a,n,key);
  printf("%d", ans);
    return 0;
}



int linearsearch( int a[], int n, int key)
{
   for(int i=0;i<n;i++)
   {
       if(a[i]==key)
        return i;
   }
    return -1;  
}



……………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………..

// recursive linear search coreman alg. implementation
#include <stdio.h>
int linearsearch(int a[], int n, int i, int key);
int main()
{
int a[20],i,n,key,ans,loc=0;
printf("enter n");
scanf("%d", &n);
printf("enter elements");
for(i=0;i<n;i++)
{
    scanf("%d", &a[i]);
}
printf("enter key");
scanf("%d", &key);
ans=linearsearch(a,n,loc,key);
printf("%d", ans);
    return 0;
}

int linearsearch(int a[], int n, int i, int key)
{
   if(i>=n)
    return -1;
    else if (a[i]==key)
    {
        return i;
    }
    else if(i<n && a[i]!=key)
     return linearsearch(a,n,i+1,key);
}

………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………

// selection sort alg. implementation acc to thomas coreman alg.
#include <stdio.h>
void selectionsort(int a[], int n);
int main() {
   int a[20], n,i;
   printf("enter n");
   scanf("%d", &n);
   printf("enter elements");
   for(i=0;i<n;i++)
   {
       scanf("%d", &a[i]);
   }
  selectionsort(a,n);
  for(i=0;i<n;i++)
   {
       printf("%d\t", a[i]);
   }
    return 0;
}

void selectionsort(int a[], int n)
{
    int i,j,smallest,temp;
    for(i=0;i<=(n-1)-1;i++)
    {
      smallest=i;
      for(j=i+1;j<=n-1;j++)
      {
          if(a[j]<a[smallest])
          {
              smallest=j;
          }
      }
      temp=a[i];
      a[i]=a[smallest];
      a[smallest]=temp;
    }
    return ;
}


………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………


//recursive binary search recursive alg. thomas coreman alg. implementation
#include <stdio.h>
int binarysearch(int a[], int low, int high, int key);
int main() {
    // Write C code here
   int a[20],n,i,low,high,mid,key,ans;
   printf("enter n ");
   scanf("%d", &n);
   printf("enter elements");
   for(i=0;i<n;i++)
   {
       scanf("%d", &a[i]);
   }
   low=0, high=n-1;
   printf("enter key");
   scanf("%d", &key);
   ans= binarysearch( a, low, high, key);
   printf("%d", ans);
    return 0;
}

int binarysearch(int a[], int low, int high, int key)
{
    int mid;
    if(low>high)
    {
        return -1;
    }
    else
    {
        while(low<=high)
        {
            mid=(low+high)/2;
            if(a[mid]==key)
            {
                return mid;
            }
            else if(a[mid]>key)
            {
               // high=mid-1;
                return binarysearch(a,low,mid-1,key);
            }
            else if(a[mid]<key)
            {
                //low=mid+1;
                return binarysearch(a,mid+1,high,key);
            }
        }
    }
}


……………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………


 // insertion sort alg. implementation thomas coreman alg. implementation
#include <stdio.h>
void insertionsort(int a[],  int n);
int main() {
    // Write C code here
   int a[20],n,i,low,high,mid,key,ans;
   printf("enter n ");
   scanf("%d", &n);
   printf("enter elements");
   for(i=0;i<n;i++)
   {
       scanf("%d", &a[i]);
   }
   low=0, high=n-1;
  
    insertionsort( a,n);
  
    return 0;
}

void insertionsort(int a[], int n)
{
    int i,j,key;
    for(i=1;i<=n-1;i++)
    {
        key=a[i];
        j=i-1;
        while(j>=0 && a[j]>key)
        {
            a[j+1]=a[j];
            j--;
        }
        a[j+1]=key;
    }
   for(i=0;i<n;i++)
   {
       printf("%d\t", a[i]);
   }
   return;
}

Merge sort implementation Thomas coreman alg. implementation in c language

#include <stdio.h>
void mergesort(int a[], int p, int r);
void merge(int a[], int p, int q, int r);
int main()
 {
    // Write C code here
    int a[20], i,n, j;
    int p,r;
    printf("enter n");
    scanf("%d", &n);
    for(i=0;i<n;i++)
    {
        scanf("%d", &a[i]);
    }
    p=0,r=n-1;
     mergesort( a,  p,  r);
     for(i=0;i<n;i++)
    {
        printf("%d\t", a[i]);
    }
    return 0;
}

void mergesort(int a[], int p, int r)
{
    int q;
    if(p>=r)
     return;
     else
     {
         q=(p+r)/2;
         mergesort(a,p,q);
         mergesort(a,q+1,r);
         merge(a,p,q,r);
     }
}

void merge(int a[], int p, int q, int r)
{
    int  n1, n2;
    int i=0,j=0,k;
    n1=q-p+1, n2=r-q;
    int b[n1], c[n2];
    for(i=0;i<n1;i++)
    {
        b[i]=a[p+i];
    }
    for(j=0;j<n2;j++)
    {
        c[j]=a[q+1+j];
    }
    b[n1]=c[n2]=999;
    
    
   int i1=0,j1=0;
   for(k=p;k<=r;k++)
   {
       if(b[i1]<=c[j1])
       {
           a[k]=b[i1];
           i1++;
       }
       else if(b[i1]>c[j1])
       {
           a[k]=c[j1];
           j1++;
       }
   }
   
    
}



…………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………………….
Thomas Coreman quicksort alg. implementation


// Online C compiler to run C program online
#include <stdio.h>
void quicksort(int a[], int p, int r);
int partion(int a[], int p, int r);

int main()
{
    int i,a[20],n,p,r;
    printf("enter n");
    scanf("%d", &n);
    for(i=0;i<n;i++)
    {
        scanf("%d", &a[i]);
    }
    p=0,r=n-1;
    quicksort( a,p, r);
     for(i=0;i<n;i++)
    {
        printf("%d\t", a[i]);
    }
    return 0;
}


void quicksort(int a[], int p, int r)
{
    int q;
    if(p<r)
    {
        q=partion(a,p,r);
        quicksort(a,p,q-1);
        quicksort(a,q+1,r);
    }
}


int partion(int a[], int p, int r)
{
    int x,i,j,temp1,temp;
    x=a[r];
    i=p-1;
    for(j=p;j<=r-1;j++)
    {
        if(a[j]<=x)
        {
            i=i+1;
            temp=a[i];
            a[i]=a[j];
            a[j]=temp;
        }
    }
   temp1=a[i+1];
   a[i+1]=a[r];
   a[r]=temp1;
   return (i+1);
} 


























